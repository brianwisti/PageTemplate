# Code Generated by ZenTest v. 2.3.0
# Couldn't find class for name User
#                 classname: asrt / meth =  ratio%
# PageTemplate::DefaultPreprocessor:    0 /    5 =   0.00%
#   PageTemplate::Namespace:    0 /    5 =   0.00%
# PageTemplate::CaseCommand:    0 /    6 =   0.00%
# PageTemplate::LoopCommand:    0 /    6 =   0.00%
#              PageTemplate:    0 /    1 =   0.00%
# PageTemplate::TextCommand:    0 /    3 =   0.00%
# PageTemplate::UnknownCommand:    0 /    3 =   0.00%
# PageTemplate::CommentCommand:    0 /    3 =   0.00%
#  PageTemplate::FileSource:    0 /    5 =   0.00%
# PageTemplate::MiniValueCommand:    0 /    1 =   0.00%
#                      User:    0 /    1 =   0.00%
# PageTemplate::IncludeCommand:    0 /    3 =   0.00%
#   PageTemplate::IfCommand:    0 /    6 =   0.00%
#     PageTemplate::Command:    0 /    2 =   0.00%
# PageTemplate::ValueCommand:    0 /    3 =   0.00%
# PageTemplate::BlockCommand:    0 /    7 =   0.00%
# PageTemplate::StackableCommand:    0 /    3 =   0.00%
#      PageTemplate::Parser:    0 /    9 =   0.00%
# PageTemplate::SyntaxGlossary:    0 /    4 =   0.00%

require 'test/unit' unless defined? $ZENTEST and $ZENTEST

require 'PageTemplate/parser.rb'
require 'PageTemplate/commands.rb'
require 'PageTemplate/case.rb'

module TestPageTemplate
  class TestBlockCommand < Test::Unit::TestCase
    def setup
      @@bc = PageTemplate::BlockCommand.new()
    end

    def test_add
      c = PageTemplate::CommentCommand.new('foo')
      assert(@@bc.add(c),
        "Use BlockCommand#add to add a new Command to the Block")
      assert_raises(TypeError,
        "BlockCommand#add only accepts Commands") {
          @@bc.add(23)
      }
    end

    def test_length
      assert_equal(0, @@bc.length,
        "Use BlockCommand#length to find out how many commands are "\
        "in the Block")
      c = PageTemplate::CommentCommand.new('foo')
      @@bc.add(c)
      assert_equal(1, @@bc.length,
        "BlockCommand#length reflects new Commands that have been " \
        "added")
    end

    def test_output
      c_1 = PageTemplate::TextCommand.new("Dude! What's mine say?\n")
      c_2 = PageTemplate::TextCommand.new("Sweet! What's mine say?\n")
      c_3 = PageTemplate::TextCommand.new("That never gets old.\n")
      @@bc.add(c_1)
      @@bc.add(c_2)
      @@bc.add(c_3)
      expected = c_1.output + c_2.output + c_3.output
      assert_equal(expected, @@bc.output)
    end
  end

  class TestCaseCommand < Test::Unit::TestCase
    def setup
      @@cc = PageTemplate::CaseCommand.new('foo')
    end

    def test_initialize
      assert(PageTemplate::CaseCommand.new('foo'))
    end

    def test_add
      assert(@@cc.add(PageTemplate::TextCommand.new("More foo?")))
    end

    def test_current_case
      # Shouldn't I be failing? I don't see an accessor for CaseCommand.current_case
      assert_equal(nil, @@cc.current_case)
      @@cc.when("1")
      assert_equal("1", @@cc.current_case)
    end

    def test_modifies_eh
      assert(@@cc.when("1"))
      assert(@@cc.else)
    end

    def test_output
      p = PageTemplate::Parser.new
      c_1 = PageTemplate::TextCommand.new("I am 1")
      c_2 = PageTemplate::TextCommand.new("I am 2")
      c_3 = PageTemplate::TextCommand.new("I don't know what I am")
      @@cc.add(c_3)
      @@cc.when("1")
      @@cc.add(c_1)
      @@cc.when("2")
      @@cc.add(c_2)
      ns = PageTemplate::Namespace.new()
      ns["foo"] = nil
      assert_equal(c_3.output, @@cc.output(ns))
      ns["foo"] = "1"
      assert_equal(c_1.output, @@cc.output(ns))
      ns["foo"] = "2"
      assert_equal(c_2.output, @@cc.output(ns))
    end
  end

  class TestCommand < Test::Unit::TestCase
    def test_output
      assert_raises(NotImplementedError,
        "Command is not to be directly used.") { 
          c = PageTemplate::Command.new
          c.output
        }
    end
  end

  class TestCommentCommand < Test::Unit::TestCase
    def test_output
      c = PageTemplate::CommentCommand.new("foo")
      assert_equal('[ Comment: foo ]', c.to_s,
        "CommentCommand stores the input string as a comment.")
      assert_equal('', c.output(),
        "CommentCommands output the empty string regardless of content.")
      c = PageTemplate::CommentCommand.new
      assert_equal('[ Comment:  ]', c.to_s,
        "Comment defaults to the string '' if you don't provide a comment.")
      c = PageTemplate::CommentCommand.new(23)
      assert_equal('[ Comment: 23 ]', c.to_s,
        "CommentCommand#to_s automatically converts comments to Strings.")
    end
  end

  class TestDefaultPreprocessor < Test::Unit::TestCase
    def test_process
      assert_equal("str", PageTemplate::DefaultPreprocessor.process("str"),
        "DefaultPreprocessor.process returns a copy of the string handed to it.")
    end

    def test_reverse
      assert_equal("rts", PageTemplate::DefaultPreprocessor.reverse("str"),
        "DefaultPreprocessor.reverse returns a reversed copy of the string handed to it.")
    end

    def test_escapeHTML
      assert_equal("&lt;str&gt;", PageTemplate::DefaultPreprocessor.escapeHTML("<str>"),
        "DefaultPreprocessor.escapeHTML returns a copy of the string input with HTML converted to entities.")
    end

    def test_escapeURI
      assert_equal("+", PageTemplate::DefaultPreprocessor.escapeURI(" "),
        "DefaultPreprocessor.escapeURI returns a URI-encoded copy of the string handed to it.")
    end
  end

  class TestDefine < Test::Unit::TestCase
    def setup
      @@p = PageTemplate::Parser.new('empty_is_true' => false)
    end

    def test_output
      template = @@p.parse("[%define zero 0%]Zero is [%var zero%]")
      assert_equal("Zero is 0", template.output,
                   "define command allows you to set values in a template")
    end
  end

  class TestFileSource < Test::Unit::TestCase
    def setup
      @@args = {}
      @@fs = PageTemplate::FileSource.new(@@args)
      # Construct an absolute path, whatever it looks like on our platform
      require 'pathname'
      cwd = Dir.getwd
      directory = "tdata"
      file = "dummy.txt"
      @@filename = File.join(directory, file)
      @@location = File.join(cwd, directory, file)
      @@text = IO.read(@@location)
    end

    def test_get
      assert_equal(@@text, @@fs.get(@@filename),
        "Dir.getwd is a path by default")
      puts "Looking for #{@@location}"
      assert_equal(@@text, @@fs.get(@@location),
        "Full path is allowed by default")
    end

    def test_get_filename
      filename = 'tdata/dummy.txt'
      location = File.join(Dir.getwd, filename)
      assert_equal(location, @@fs.get_filename(filename))
    end

    def test_paths
      assert_equal([Dir.getwd,'/'], @@fs.paths)
    end

    def test_include_path
      fs = PageTemplate::FileSource.new(
          'include_path' => File.join(Dir.getwd,'tdata')
        )
      assert_equal([File.join(Dir.getwd,'tdata')],fs.paths,
        "Explicit set include_path should only include the one element")
      assert_equal(@@text,fs.get('dummy.txt'),
        "Just a filename of something in an include path works")
    end
    def test_include_paths
      location = File.dirname(@@location)
      ptlocation = File.join(Dir.getwd,'lib')
      pt = IO.read(File.join(ptlocation,'PageTemplate.rb'))
      fs = PageTemplate::FileSource.new(
          'include_paths'=>[location,ptlocation]
        )
      assert_equal([location,ptlocation],fs.paths,
        "Explicit set include_paths should include all set elements")
      assert_equal(@@text,fs.get('dummy.txt'),
        "Just a filename of something in an include path works")
      assert_equal(pt,fs.get('PageTemplate.rb'),
        "Just a filename of something in an include path works")
    end
  end

  class TestFilterCommand < Test::Unit::TestCase
    def setup
      @@p = PageTemplate::Parser.new()
    end

    def test_filter
      source = "[%filter :reverse %]foo[%end%]"
      assert_equal("oof", @@p.parse(source).output,
                   "FilterCommands can be used to filter raw template text.")
      @@p["f"] = "boy"
      source = "[%filter :reverse %][%var f%][%end%]"
      assert_equal("yob", @@p.parse(source).output,
                   "Commands in a FilterCommand are parsed before filtering")
    end
  end

  class TestIfCommand < Test::Unit::TestCase
    def setup
      @@if     = PageTemplate::IfCommand.new("if", "flag")
      @@unless = PageTemplate::IfCommand.new("unless", "flag")
    end

    def test_initialize
      good_1 = "if flag"
      good_2 = "unless flag"
      bad_1  = "heck no"
      assert(PageTemplate::IfCommand.new("if", "flag"))
      assert(PageTemplate::IfCommand.new("unless", "flag"))
      assert_raises(ArgumentError,
        "IfCommand will not initialize without a command declaring 'if/unless'") {
          PageTemplate::IfCommand.new(bad_1)
      }
    end

    def test_add
      c = PageTemplate::TextCommand.new("bleargh")
      assert(@@if.add(c),
        "IfCommand#add adds a command to the block to be executed when true")
      assert(@@unless.add(c),
        "IfCommand#add adds a command to the block to be executed when false")
    end

    def test_else
      assert(@@if.else)
      assert(@@unless.else)
    end

    def test_elsif
      ns = PageTemplate::Namespace.new
      parser = PageTemplate::Parser.new
      tester = PageTemplate::IfCommand.new('if','redflag')
      tester.add(PageTemplate::TextCommand.new('Red Flag'))
      tester.elsif('blueflag')
      tester.add(PageTemplate::TextCommand.new('Blue Flag'))
      tester.elsif('greenflag')
      tester.add(PageTemplate::TextCommand.new('Green Flag'))
      tester.else
      tester.add(PageTemplate::TextCommand.new('No Flag'))

      assert_equal('No Flag',tester.output(ns))
      ns['greenflag'] = true
      assert_equal('Green Flag',tester.output(ns))
      ns['blueflag'] = true
      assert_equal('Blue Flag',tester.output(ns))
      ns['redflag'] = true
      assert_equal('Red Flag',tester.output(ns))
    end

    def test_output
      ns = PageTemplate::Namespace.new()
      c = PageTemplate::TextCommand.new("dude!")
      assert_equal("dude!", c.output())
      @@if.add(c)
      @@unless.add(c)
      ns["flag"] = true
      assert_equal("dude!", @@if.output(ns))
      assert_equal("", @@unless.output(ns))
      ns["flag"] = false
      assert_equal("", @@if.output(ns))
      assert_equal("dude!", @@unless.output(ns))
      @@if.else
      @@unless.else
      c2 = PageTemplate::TextCommand.new("sweet!")
      @@if.add(c2)
      @@unless.add(c2)
      ns["flag"] = true
      assert_equal("dude!", @@if.output(ns))
      assert_equal("sweet!", @@unless.output(ns))
      ns["flag"] = false
      assert_equal("sweet!", @@if.output(ns))
      assert_equal("dude!", @@unless.output(ns))
    end
    def test_empty_false
      parser = PageTemplate::Parser.new('empty_is_true' => false)
      template = parser.parse('[%if foo%]Foo[%else%]Bar[%end%]')
      template['foo'] = []
      assert_equal(template.output,'Bar')
      parser.args['empty_is_true'] = true
      assert_equal(template.output,'Foo')
    end
  end

  class TestIncludeCommand < Test::Unit::TestCase
    def test_simple_output
      parser = PageTemplate::Parser.new()
      parser['dummy'] = File.join("tdata", "dummy.txt")
      i = PageTemplate::IncludeCommand.new('dummy')
      parser.load('tdata/dummy.txt')
      assert_equal(parser.output, i.output(parser))
    end

    def test_include_template
      pt = PageTemplate::Parser.new("include_path" => "tdata/")
      pt.load("include.txt")
      pt["file"] = "variable.txt"
      pt["name"] = "Phil"
      assert(pt.output =~ /Hello, Phil!/,
             "Included files are parsed as templates.")
      pt.source.paths = [ Dir.getwd ]
      pt.load("tdata/include.txt")
      assert(pt.output =~ /variable.txt/,
             "Filename for includes may include directories")
    end

    def test_include_literal
      pt = PageTemplate::Parser.new("include_path" => "tdata")
      pt.load("include2.txt")
      assert(pt.output =~ /get_filename/,
             "Include Commands can be handed a filename directly")
    end
  end

  class TestLoopCommand < Test::Unit::TestCase
    def setup
      @@in = PageTemplate::LoopCommand.new("in", "list", "")
      @@loop = PageTemplate::LoopCommand.new("loop", "list", "")
    end

    def test_initialize
      assert(PageTemplate::LoopCommand.new("in", "list", ""))
      assert(PageTemplate::LoopCommand.new("in", "loop", ""))
      assert(PageTemplate::LoopCommand.new("in", "list", "item"))
    end

    def test_add
      c = PageTemplate::TextCommand.new("bleargh")
      assert(@@loop.add(c),
        "LoopCommand#add adds a command to the block to be executed in the loop")
    end

    def test_else
      assert(@@loop.else)
    end

    def test_output
      parser = PageTemplate::Parser.new()
      ns = PageTemplate::Namespace.new()
      ns.parent = parser
      ns["list"] = [1, 2, 3]

      # Simple TextCommands in a Loop
      c = PageTemplate::TextCommand.new("Dude!")
      loop_1 = PageTemplate::LoopCommand.new("loop", "list", "")
      loop_1.add(c)
      assert_equal("Dude!Dude!Dude!", loop_1.output(ns))
      c_1 = PageTemplate::TextCommand.new("Sweet!")
      loop_1.add(c_1)
      assert_equal("Dude!Sweet!Dude!Sweet!Dude!Sweet!", loop_1.output(ns))
      ns["list"] = nil
      assert_equal("", loop_1.output(ns))

      # Simple TextCommands in a Loop with an Else block
      c_1 = PageTemplate::TextCommand.new("Sweet!")
      c_2 = PageTemplate::TextCommand.new("Dude?")
      loop_2 = PageTemplate::LoopCommand.new("loop", "list", "")
      loop_2.add(c_1)
      loop_2.else
      loop_2.add(c_2)
      ns["list"] = nil
      assert_equal("Dude?", loop_2.output(ns))
      ns["list"] = [1, 2]
      assert_equal("Sweet!Sweet!", loop_2.output(ns))

      # A Loop that uses its metavariables
      c_1 = PageTemplate::TextCommand.new("First Post!")
      c_2 = PageTemplate::TextCommand.new("I know kung fu.")
      c_3 = PageTemplate::TextCommand.new("Prove it.")
      c_4 = PageTemplate::TextCommand.new("Last Post!")
      if_1 = PageTemplate::IfCommand.new("if", "__FIRST__")
      if_1.add(c_1)
      if_2 = PageTemplate::IfCommand.new("if", "__ODD__")
      if_2.add(c_2)
      if_2.else
      if_2.add(c_3)
      if_3 = PageTemplate::IfCommand.new("if", "__LAST__")
      if_3.add(c_4)
      loop_1 = PageTemplate::LoopCommand.new("in", "cliches", "")
      loop_1.add(if_1)
      loop_1.add(if_2)
      loop_1.add(if_3)
      ns["cliches"] = [1, 2]
      expected = c_1.output + c_2.output + c_3.output + c_4.output
      assert_equal(expected, loop_1.output(ns))

      # A Loop with a named iterator over the items in its list
      loop_1 = PageTemplate::LoopCommand.new("in", "list", "item")
      c_1 = PageTemplate::ValueCommand.new("item", nil)
      c_2 = PageTemplate::TextCommand.new(" ")
      loop_1.add(c_1)
      loop_1.add(c_2)
      ns["list"] = [0, -1, 2, -3, 4]
      expected = ns["list"].join(" ") + " "
      assert_equal(expected, loop_1.output(ns))

      # A loop with multiple iterators
      loop_1 = PageTemplate::LoopCommand.new("in", "names", "key val")
      c1 = PageTemplate::ValueCommand.new("key",nil)
      c2 = PageTemplate::ValueCommand.new("val",nil)
      tc = PageTemplate::TextCommand.new(": ")
      loop_1.add c1
      loop_1.add tc
      loop_1.add c2
      ns["names"] = { 'Brian' => 'Wisti', 'Greg' => 'Millam' }
      out = ns["names"].map { |fn,ln| "#{fn}: #{ln}" }.join('')
      assert_equal(out,loop_1.output(ns))
    end
  end

  class TestNamespace < Test::Unit::TestCase
    def setup
      @@ns = PageTemplate::Namespace.new
    end

    def test_nested_namespaces
      @@ns.object = {'meat'=>'Caribou Eyes'}
      p = PageTemplate::Namespace.new
      @@ns.parent = p
      p['soda'] = 'Ebola Cola' # Transmetropolitan! Read it!
      assert_equal(@@ns.get('meat'),'Caribou Eyes',
          'Namespace#get(meat) did not return correct value!')
      assert_equal(@@ns.get('soda'),'Ebola Cola',
          'Namespace#get(meat) did not return parent\'s correct value!')
    end

    def test_clear_cache
      assert(@@ns.clear_cache,
        "Use Namespace#clear_cache to reset a Namespace's values.")
    end

    def test_get
      assert_nil(@@ns.get("Santa Claus"),
        "If a key is not set, Namespace#get returns nil")
      @@ns.set("Santa Claus", "Kris Kringle")
      assert_equal("Kris Kringle", @@ns.get("Santa Claus"),
        "Use Namespace#get to access to Namespace value")

      assert_equal(nil, @@ns.get("occupation"))
      p = PageTemplate::Namespace.new()
      p["occupation"] = "Foole"
      @@ns.parent = p
      assert_equal("Foole", @@ns.get("occupation"),
        "Namespace#get will search parent Namespaces if they are available")

      assert_equal(nil, @@ns.get("abs"))
      @@ns.object = -5
      assert_equal(5, @@ns.get("abs"),
        "Namespace#get will send get requests to a contained object if it is available")

      assert_equal(3,@@ns.get("succ.succ.abs"),
        "Namespace#get will send get requests subsequently to accessors if available")

      @@ns.set("list", ['one','two','three'])
      assert_equal('two',@@ns.get('list.1'),
        "If an accessor looks like an integer, it's an array index")

      @@ns.set('fruits',{'a'=>'apple','b'=>'banana'})
      assert_equal('banana',@@ns.get('fruits.b'),
        "If an object has_key?(b), it checks get object['b'] rather than send(:b)")
      @@ns.set(:title, "xyz")
      assert_equal("xyz", @@ns.get("title"),
                   "Symbols may be used as Namespace keys")
    end

    def test_index
      @@ns.set("Santa Claus", "Kris Kringle")
      assert_equal("Kris Kringle", @@ns["Santa Claus"],
        "Use Namespace#get to access to Namespace value")
    end

    def test_index_equals
      assert(@@ns["Dude"] = "Sweet!",
        "Namespace#[]= is an alias for Namespace#set.")
      assert_equal("Sweet!", @@ns["Dude"])
    end

    def test_object
      assert_equal(nil, @@ns.object)
      @@ns.object = -5
      assert_equal(-5, @@ns.object,
        "Namespace#object is a getter for a Namespace's object")
    end

    def test_object_equals
      obj = -5
      assert(@@ns.object = obj,
        "Namespace#object= is a setter for a Namespace's object")
      assert_equal(-4, @@ns.get('succ'),
        "Namespace#object= defines an object to search for synonyms")
    end

    def test_parent
      assert_equal(nil, @@ns.parent)
      p = PageTemplate::Namespace.new()
      p["occupation"] = "Foole"
      @@ns.parent = p
      assert_equal(p, @@ns.parent,
        "'parent' is a getter for a parent Namespace")
    end

    def test_parent_equals
      p = PageTemplate::Namespace.new()
      p["occupation"] = "Foole"
      assert(@@ns.parent = p,
        "'parent' is a setter for a parent Namespace")
    end

    def test_set
      assert(@@ns.set("dude", "sweet!"),
        "Use Namespace#set to set names to a value in your Namespace.")
      assert(@@ns["sweet"] = "dude",
        "Namespace#[]= is an alias for Namespace#set.")
    end

    def test_true_eh
      assert_equal(false, @@ns.true?("enlightenment"),
        "If a flag doesn't exist, then Namespace#true? returns false.")
      @@ns["dude"] = false
      assert_equal(false, @@ns.true?("dude"),
        "If a flag is set to false, then Namespace#true? returns false.")
      @@ns["dude"] = true
      assert_equal(true, @@ns.true?("dude"),
        "If a flag is set to true, then Namespace#true? returns true.")
      @@ns["dude"] = "sweet!"
      assert_equal(true, @@ns.true?("dude"),
        "If a flag is set to pretty much anything but false, then Namespace#true? returns true.")
    end

    class Foo
      def initialize(str)
        @str = str
      end
      def bar
        @str
      end
    end

    def test_deep_true_eh
      @@ns['foo'] = Foo.new('fizbit')
      assert(@@ns.true?('foo.bar'),"foo.bar must be true")
      assert(@@ns.true?('foo.bar.reverse'))
      assert_equal(@@ns.get('foo.bar.reverse'),'tibzif')
    end

    def test_delete
      @@ns['dude'] = "Sweet"
      assert_equal(@@ns.get("dude"), "Sweet")
      @@ns.delete("dude")
      assert_equal(nil, @@ns.get("dude"))
    end
  end

  class TestParser < Test::Unit::TestCase
    def setup
      @@tc = PageTemplate::TextCommand.new("[ Template 'foo' not found ]")
      @@p = PageTemplate::Parser.new()
    end

    def test_args
      assert_equal({}, @@p.args)
    end

    def test_namespace_arg
      require 'yaml'
      ns = PageTemplate::Namespace.new()
      ns['oompa'] = 'loompa'
      p = PageTemplate::Parser.new('namespace' => ns)
      assert_equal('loompa', p['oompa'])
      p = PageTemplate::Parser.new('namespace' => { 'oompa' => 'loompa' })
      assert_equal('loompa', p['oompa'])
      # This assertion is just for my own peace of mind.
      y = YAML::load({ 'doompity' => 'doo' }.to_yaml)
      p = PageTemplate::Parser.new('namespace' => y)
      assert_equal('doo', p['doompity'])
    end

    def test_clearCommands
      @@p.clearCommands
      assert_equal(nil, @@p.commands)
    end

    def test_commands
      assert_equal(nil, @@p.commands)
      @@p.load('foo')
      assert(@@p.commands)
    end

    def test_compile
      assert_equal(@@tc.output, @@p.compile('foo').output)
      $SAFE = 1
      assert_equal(@@tc.output, @@p.compile('foo').output)
    end

    def test_default_processor
      assert_equal(:unescaped, @@p.default_processor)
    end

    def test_load
      assert(@@p.load('foo'))
    end

    def test_output
      assert_equal('', @@p.output)
      @@p.load('foo')
      assert_equal(@@tc.output, @@p.output)
    end

    def test_parse
      assert_equal('', @@p.parse('').output)
      assert_equal('foo', @@p.parse('foo').output)
      @@p['x'] = 'y'
      assert_equal('y', @@p.parse('[%var x%]').output)
    end

    def test_preprocessor
      assert_equal(PageTemplate::DefaultPreprocessor, @@p.preprocessor)
    end

    def test_index
      assert_equal(nil, @@p['foo'])
      @@p['foo'] = "Are you sick of foo yet?"
      assert_equal("Are you sick of foo yet?", @@p['foo'])
    end

    def test_index_equals
      assert(@@p['foo'] = "I'm sick of foo!")
    end
  end

  class TestStringSource < Test::Unit::TestCase
    def test_get
      str = "John Jacob Jingleheimer Smith"
      ss = PageTemplate::StringSource.new(str)
      assert_equal(str, ss.get,
                   "StringSource holds a simple String")
      ss = PageTemplate::StringSource.new("source" => str)
      assert_equal(str, ss.get,
                   "StringSource holds a simple String")
    end
  end

  class TestSyntaxGlossary < Test::Unit::TestCase
    # Test modifications by gmillam
    def setup
      @@g = Class.new(PageTemplate::SyntaxGlossary)
      @@g.directive = /<(.+?)>/
      @@g.define(/^--(.*)/) { |match|
        PageTemplate::CommentCommand.new(match[1])
      }
      @@g.default { |command|
        PageTemplate::UnknownCommand.new(command)
      }
    end

    def test_define
      # lookup() now returns instances, not classes
      # assert_equal(PageTemplate::UnknownCommand, @@g.lookup("foo"))
      assert_raises(ArgumentError,
        "SyntaxGlossary#define requires a Regexp for its argument") {
          @@g.define("foo") {}
      }
      assert_raises(ArgumentError,
        "SyntaxGlossary#define requires a block to be passed") {
        @@g.define("foo")
      }
      assert(@@g.define(/^foo/) {|m,p|},
        "Use SyntaxGlossary#define to add or change SyntaxGlossary entries")
    end

    def test_define_global_var
      assert_equal(true, @@g.lookup("d").is_a?(PageTemplate::UnknownCommand))
      assert(@@g.define_global_var(/d/),
        "Use SyntaxGlossary#define_global_var to create explicit ValueCommands")
      assert_equal(true, @@g.lookup("d").is_a?(PageTemplate::ValueCommand))
    end

    def test_directive
      assert_equal(/<(.+?)>/, @@g.directive)
    end

    def test_directive_equals
      assert_equal(/<(.+?)>/, @@g.directive)
      directive = /\[.+?\]/
      assert(@@g.directive = directive)
      assert_equal(directive, @@g.directive)
      @@g.directive = /<(.+?)>/
    end

    def test_lookup
      assert_equal(true, @@g.lookup("--").is_a?(PageTemplate::CommentCommand))
      assert_equal(true, @@g.lookup("++").is_a?(PageTemplate::UnknownCommand))
    end
  end

  class TestTextCommand < Test::Unit::TestCase
    def test_output
      c = PageTemplate::TextCommand.new("Dude!")
      assert_equal("Dude!", c.output(),
        "A TextCommand outputs a simple text string.")
    end
  end

  class TestUnknownCommand < Test::Unit::TestCase
    def test_output
      parser = PageTemplate::Parser.new()
      uc = PageTemplate::UnknownCommand.new("waffle olive mango")
      assert_equal("[ Unknown Command: waffle olive mango ]", uc.output(parser.namespace))
    end
  end

  class TestHTGlossary < Test::Unit::TestCase
    def setup
      begin
        require 'PageTemplate/htglossary'
        @parser = PageTemplate::Parser.new('glossary' => PageTemplate::HTGlossary)
      rescue Exception => er
        puts "error: #{er}"
        @parser = nil
      end
    end
    def test_comment_style
      assert(@parser,'HTGlossary parser was not created')
      tmpl = @parser.parse('<!-- TMPL_VAR foo -->')
      tmpl['foo'] = 'bar'
      assert_equal('bar',tmpl.output,'A TMPL_VAR command by itself')
      tmpl = @parser.parse('<!-- TMPL_IF foo -->foo<!--TMPL_ELSE-->bar<!-- /TMPL_IF -->')
      tmpl['foo'] = true
      assert_equal('foo',tmpl.output,'TMPL_IF does not work in comment style')
      tmpl['foo'] = false
      assert_equal('bar',tmpl.output,'TMPL_IF does not work in comment style')
    end
    def test_tag_style
      assert(@parser,'HTGlossary parser was not created')
      tmpl = @parser.parse('<TMPL_VAR foo>')
      tmpl['foo'] = 'bar'
      assert_equal('bar',tmpl.output,'A TMPL_VAR command by itself')
      tmpl = @parser.parse('<TMPL_IF foo>foo<TMPL_ELSE>bar</TMPL_IF>')
      tmpl['foo'] = true
      assert_equal('foo',tmpl.output,'TMPL_IF does not work in comment style')
      tmpl['foo'] = false
      assert_equal('bar',tmpl.output,'TMPL_IF does not work in comment style')
    end
  end

  class TestValueCommand < Test::Unit::TestCase
    def test_output
      p = PageTemplate::Parser.new()
      p['x'] = 'y'
      v = PageTemplate::ValueCommand.new('x',nil)
      assert_equal('y', v.output())
      assert_equal('y', v.output(p.namespace))
      p['x'] = 1
      v = PageTemplate::ValueCommand.new('x.succ.foo', nil)
      w = PageTemplate::ValueCommand.new('x.succ.succ.succ', nil)
      assert_equal('4',w.output(p.namespace))
      assert_equal('',v.output(p.namespace))
    end

    def test_raise_on_error
      p = PageTemplate::Parser.new
      template = p.parse("[% var foo.bar %]")
      foo = "hello"

      def foo.bar
        asdf # method unknown error
      end

      template["foo"] = foo
      assert_equal(
        template.output,
        "[ Error: undefined local variable or method `asdf' for \"hello\":String ]",
        "With raise_on_error not set, we get error strings")
      p.args['raise_on_error'] = true
      assert_raises(NameError,
        "With raise on error set, user has to catch errors") {
        template.output
      }
    rescue Exception => er
      puts "error: #{er.class}"
    end

  end
end

